import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile, Aer
import numpy as np

def average_Jz(params, num_qubits, num_shots, delta_phi, nEn, nDe):
    phi = params[0]

    qc = QuantumCircuit(num_qubits, num_qubits)

    for i in range(num_qubits):
        qc.ry(np.pi/2)

    for j in range(nEn):
        for i in range(num_qubits-1, 0, -1):
            qc.cx(i, i-1)
        qc.cz(0, num_qubits-1)
        
    # phase shift
    for i in range(num_qubits-1):
        qc.cp(phi, i, num_qubits-1)

    # decoding
    for j in range(nDe):
        for i in range(num_qubits-1, 0, -1):
            qc.cx(i, i-1)
        qc.cz(0, num_qubits-1)

    # Apply the inverse QFT to the first num_qubits qubits
    qc.append(QFT(num_qubits).inverse(), range(num_qubits))

    for i in range(num_qubits):
        qc.rx(np.pi/2)
    
    for i in range(num_qubits):
        qc.measure(i, i)

    simulator = Aer.get_backend('qasm_simulator')
    job = simulator.run(transpile(qc, simulator), shots=num_shots)
    result = job.result()

    counts = result.get_counts(qc)

    # average Jz
    Jz = 0
    for state, count in counts.items():
        Jz += count * (-1) ** sum([int(bit) for bit in state])
    Jz /= num_shots

    # Normalize Jz
    Jz_normalized = Jz / (num_qubits / 2)

    return Jz_normalized

num_qubits = 16
num_shots = 1000
delta_phi = 0.7
phi_value = np.pi / 4
nEn = 0
nDe = 0

#phi_values = np.linspace(-np.pi, np.pi, 100)

depths = [(0,0), (1, 1), (2, 2), (3, 3)]

average_Jz_values = []

for nEn, nDe in depths:
    print(f"Circuit for nEn={nEn}, nDe={nDe}:")
    qc = QuantumCircuit(num_qubits, num_qubits)

    for i in range(num_qubits):
        qc.h(i)

    # entangling
    for j in range(nEn):
        for i in range(num_qubits-1):
            qc.cx(i, i+1)
        qc.cz(num_qubits-1, 0)

    # phase shift
    for i in range(num_qubits-1):
        qc.cp(phi_value, i, num_qubits-1)

    # decoding
    for j in range(nDe):
        for i in range(num_qubits-1, 0, -1):
            qc.cx(i, i-1)
        qc.cz(0, num_qubits-1)

    qc.append(QFT(num_qubits).inverse(), range(num_qubits))

    for i in range(num_qubits):
        qc.measure(i, i)



    average_Jz_values.append([average_Jz([phi], num_qubits, num_shots, delta_phi, nEn, nDe) for phi in phi_values])

# Plot the results
plt.figure(figsize=(10, 5))
for i, (nEn, nDe) in enumerate(depths):
    plt.plot(phi_values, average_Jz_values[i], label=f'nEn={nEn}, nDe={nDe}')
plt.xlabel
